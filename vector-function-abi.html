<!doctype html>
<html lang=en>
<head><title> POWER8 Vector Function ABI Specification </title>
</head>
<body>

<h1>
Vector Function Application Binary Interface Specification for POWER8 Processor
</h1>

<p style="page-break-before: always"></p>
<h2> Vector Function Overview </h2>

The vector (simd in OpenMP literature) function annotation applies to C/C++
functions. Either OpenMP pragma or GCC __attribute__ syntax can be used to
enable function vectorization.

Use of simd annotation on function declaration or definition allows the
compiler to create vector versions of a function from the scalar function
definition provided. The vector versions of functions are used, when
appropriate, in the optimization steps of compilation (e.g. automatic loop
vectorization)

This ABI defines the details of the caller-callee interface for vector
functions; including parameter passing to and returning values from vector
functions and C/C++ syntax used to inform GCC of features of the relevant
functions.
<h2> Vector Function ABI </h2>

The vector function ABI defines a set of rules that the caller and callee must
obey. These rules consist of:
<ul>
<li> Calling convention (how arguments are passed to the vector function and
how values are returned from the vector function) </li>
<li> Vector length </li>
<li> Vector function masking </li>
<li> Mapping from existing data types to vector data types </li>
<li> Vector function name mangling </li>
</ul>

<h2> Calling Convention </h2>
All functions (including compiler-created vector functions) use the Function
Calling Sequence defined in OpenPOWER 64-bit ELF V2 ABI Specification for Power
Architecture.
<h2> Vector Length </h2>
A set of vector lengths VLEN is associated with a vector function F. The algorithm
which determines the value(s) for VLEN is described below after a few required
definitions are given.
<h3> Lane Size of a function parameter or function return value </h3>
Lane Size of P, or LS(P) is defined as:
<ul>
<li> If MTV(P) is false and P is a pointer or reference to some type T for
which PBV(T) is true, LS(P) = sizeof(T). </li>
<li> If PBV(T(P)) is true, LS(P) = sizeof(P). </li>
<li> Otherwise LS(P) = sizeof(uintptr_t). </li>
</ul>
<h3> Narrowest and Widest Data Size of a Function </h3>
For a function f, the following concepts are defined:
<ul>
<li> The Narrowest Data Size of f, or NDS(f), is the minimum of the lane size
LS(P) among all input parameters and return value &ltP&gt of f. </li>
<li> The Widest Data Size of f, or WDS(f), is the maximum of the lane size
LS(P) among all input parameters and return value &ltP&gt of f. </li>
</ul>
By definition the only values that NDS(f) and WDS(f) can take are 1, 2, 4, 8,
and 16.

The rules for determining VLEN are:
<ul>
<li> If simdlen(len) is specified then VLEN=len. The value of len must be a
power of 2.</li>
<li> If simdlen is not specified, then VLEN is set using rules:</li>
</ul>

<ol>
<li> if NDS(f) = 1, then VLEN = 16, 8; </li>
<li> if NDS(f) = 2, then VLEN = 8, 4; </li>
<li> if NDS(f) = 4, then VLEN = 4, 2; </li>
<li> if NDS(f) = 8 or NDS(f) = 16, then VLEN = 2; </li>
</ol>


</body>
</html>
