<!doctype html>
<html lang=en>
<head><title> POWER8 VSX Vector Function ABI Specification </title>
</head>
<body>

<h1>
Vector Function Application Binary Interface Specification for POWER8 VSX ISA
</h1>

<p style="page-break-before: always"></p>
<h2> Vector Function Overview </h2>

The vector (simd in OpenMP literature) function annotation applies to C/C++
functions. Either OpenMP pragma or GCC __attribute__ syntax can be used to
enable function vectorization.

Use of simd annotation on function declaration or definition allows the
compiler to create vector versions of a function from the scalar function
definition provided. The vector versions of functions are used, when
appropriate, in the optimization steps of compilation (e.g. automatic loop
vectorization)

This ABI defines the details of the caller-callee interface for vector
functions; including parameter passing to and returning values from vector
functions and C/C++ syntax used to inform GCC of features of the relevant
functions.
<h2> Vector Function ABI </h2>

The vector function ABI defines a set of rules that the caller and callee must
obey. These rules consist of:
<ul>
<li> Calling convention (how arguments are passed to the vector function and
how values are returned from the vector function) </li>
<li> Mapping from existing data types to vector data types </li>
<li> Vector length </li>
<li> Vector function masking </li>
<li> Vector function name mangling </li>
</ul>

<h2> Calling Convention </h2>
All functions (including compiler-created vector functions) use the Function
Calling Sequence defined in OpenPOWER 64-bit ELF V2 ABI Specification for Power
Architecture.
<h2>  Mapping from existing data types to vector data types </h2>
One or more vector functions F are associated with an original scalar function
f. The return value and each function parameter of f are mapped to unique return
value and input parameter of F, respectively, named Mapping of P or MAP(P). The
type of these vector function return value and input parameters depends on the
following rules. Their order is the same as in the original scalar function f.
<h3> Maps to Vector </h3>
To each &ltP&gt, a true &#47 false predicate "P Maps to Vector," or MTV(P), is
associated as follows:
<ol>
<li> If &ltP&gt is an input parameter such that:
<ol>
<li> &ltP&gt is a uniform value, or </li>
<li> &ltP&gt is a linear value and not a reference marked with val or no linear
modifiers, </li>
then MTV(P) is false.
</ol>
</li>
<li> If P is a void return value, then MTV(P) is false; </li>
<li> In all other cases, MTV(P) is true. </li>
</ol>


<h3> Pass By Value </h3>
When a scalar parameter maps to a vector, that vector sometimes contains the
values of the scalar parameters and sometimes contains the addresses of the
scalar parameters. The predicate Pass By Value PBV(T) is true if the former
case applies to parameters of type T; it is false if the latter case applies.
The predicate is defined as follows:
<ol>
<li> PBV(T) is true if (a) T is an integer, floating-point or pointer type and
(b) sizeof(T) is 1, 2, 4, or 8. </li>
<li> PBV(T) is true if T is a complex type with components of type T' and if
PBV(T') is true. </li>
<li> Otherwise PBV(T) is false. </li>
</ol>

<h3> Parameter and return value mapping </h3>
When mapping the return value or an input parameter &ltP&gt of the scalar
function to the corresponding MAP(P) in the vector function, the following
rules apply:
<ol>
<li> If MTV(P) is false, then MAP(P) is P. </li>
<li> Otherwise, MTV(P) is true, and MAP(P) is defined as:
<ol>
<li>If PBV(T(P)) is false, MAP(P) is a vector of VLEN elements of type
uintptr_t. </li>
<li> If T(P) is a complex type with components of type T, MAP(P) is a vector of
2*VLEN elements of type T. </li>
<li> Otherwise MAP(P) is a vector of VLEN elements of type T(P). </li>
An optional {not}inbranch clause defines whether or not a vector mask parameter
is added as the last input parameter of F, according to the rules in table NNN
in chapter NNN. The vector mask type is selected by building a vector of VLEN
elements consisting of unsigned integers of NDS(f) bytes. The generation of the
values in the mask parameter is described in section NNN.
</ol>
</li>
<li>In all cases, when &ltP&gt is the return value, and:
<ol>
<li> MTV(P) = true. </li>
<li> PBV(P) = false. </li>
<li> MAP(P) is a vector of pointers. </li>
</ol>
Then the return type of the associated vector function is void, and MAP(P)
becomes the first parameter of the vector function. The caller is responsible
for allocating the memory associated with the pointers in MAP(P).
</li>
</ol>

<h2> Vector Length </h2>
A set of vector lengths VLEN is associated with a vector function F. The algorithm
which determines the value(s) for VLEN is described below after a few required
definitions are given.
<h3> Lane Size of a function parameter or function return value </h3>
Lane Size of P, or LS(P) is defined as:
<ul>
<li> If MTV(P) is false and P is a pointer or reference to some type T for
which PBV(T) is true, LS(P) = sizeof(T). </li>
<li> If PBV(T(P)) is true, LS(P) = sizeof(P). </li>
<li> Otherwise LS(P) = sizeof(uintptr_t). </li>
</ul>
<h3> Narrowest and Widest Data Size of a Function </h3>
For a function f, the following concepts are defined:
<ul>
<li> The Narrowest Data Size of f, or NDS(f), is the minimum of the lane size
LS(P) among all input parameters and return value &ltP&gt of f. </li>
<li> The Widest Data Size of f, or WDS(f), is the maximum of the lane size
LS(P) among all input parameters and return value &ltP&gt of f. </li>
</ul>
By definition the only values that NDS(f) and WDS(f) can take are 1, 2, 4, 8,
and 16.

The rules for determining VLEN are:
<ul>
<li> If simdlen(len) is specified then VLEN=len. The value of len must be a
power of 2.</li>
<li> If simdlen is not specified, then VLEN is set using rules:</li>
</ul>

<ol>
<li> if NDS(f) = 1, then VLEN = 16, 8; </li>
<li> if NDS(f) = 2, then VLEN = 8, 4; </li>
<li> if NDS(f) = 4, then VLEN = 4, 2; </li>
<li> if NDS(f) = 8 or NDS(f) = 16, then VLEN = 2; </li>
</ol>

<h2> Vector function masking </h2>
The inbranch and notinbranch clauses define whether or not a vector function
should accept a masking parameter. In all cases, the masking parameter is added
to the vector function signature as the last parameter.
For masked vector functions, additional "mask" parameters are required. The
type of the mask is generated using uint[NDS(f)*8]_t-based vectors.
All bits  are set to one for active lanes, and all bits are set to zero for
inactive lanes.

<h2> Vector function name mangling </h2>
The name mangling of generated vector functions based on standardized
annotation is an important part of this ABI. It allows caller and callee
functions to be separately compiled. Using the function prototypes in header
files to communicate vector function annotation information, the compiler can
perform function matching when vectorizing code at call sites.  The vector
function name is mangled as the concatenation of the following items:

&ltprefix&gt &ltisa&gt &ltmask&gt &ltlen&gt &ltparameters&gt "_"
&ltoriginal_name&gt <br>
&ltprefix&gt := "_ZGV" <br>
&ltisa&gt := "b" (VSX) <br>
&ltmask&gt := "N" (No Mask) <br>
            | "M" (Mask) <br>
&ltlen&gt := VLEN <br>
&ltparameters&gt := /* empty */ <br>
                  | &ltparameter&gt &ltopt-align&gt &ltparameters&gt <br>
&ltparameter&gt := "s" // linear parameter, variable stride, decimal number is <br>
                       // the position # of stride argument, starting from 0 <br>
                 | "l" &ltnumber&gt // linear parameter, constant stride <br>
                 | "u" // uniform parameter <br>
                 | "v" // vector parameter <br>
&ltopt-align&gt := /* empty*/ <br>
                 | "a" non-negative decimal integer <br>
&ltnumber&gt := [n] non-negative decimal integer // n indicates negative <br>


</ol>
</body>
</html>
