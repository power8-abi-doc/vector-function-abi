<!doctype html>
<html lang=en>
<head><title> POWER Architecture Vector Function Application Binary Interface
Specification
</title>
</head>
<body>

<h1>
Vector Function Application Binary Interface Specification for POWER
Architecture
</h1>

<h2> Vector Function ABI Overview </h2>
This Vector Function ABI provides the ABI for vector functions generated by GCC
compilers supporting SIMD constructs of OpenMP 4.0 [1] and above. These SIMD
constructs are also available without OpenMP in GCC compilers that implement
the __attribute__ ((__simd__)) for function declarations and definitions.
<pre><br></pre>
The ABI described here applies only for C/C++ functions.
<pre><br></pre>
Use of a SIMD construct for a function declaration or definition enables the
creation of vector versions of the function from the scalar version of the
function. The vector variants can be used to process multiple instances
concurrently in a single invocation in a vector context (e.g., most typically
in vectorizing loops during the optimization phase of compilation.)
<pre><br></pre>
For a function definition, use of #pragma omp declare simd or __attribute__
((__simd__)) enables creation of vector versions by the compiler.
<pre><br></pre>
For a function declaration, use of #pragma omp declare simd or __attribute__
((__simd__)) enables the compiler to know the exact list of available vector
function implementations provided by a library. The library's vector functions
will use the OpenMP pragma or GCC attribute SIMD constructs in their
prototypes.
<pre><br></pre>
The Vector Function ABI defines a set of rules that caller and callee functions
must obey. The rules consist of:
<ul>
<li> Calling convention (how arguments are passed to the vector function and
how values are returned from the vector function) </li>
<li> Vector length (the number of concurrent scalar invocations to be processed
per invocation of the vector function)</li>
<li> Mapping from element data types to vector data types </li>
<li> Ordering of vector arguments </li>
<li> Vector function masking </li>
<li> Vector function name mangling </li>
<li> Compiler generated vector function variants </li>
</ul>

This specification shall be considered an extension to the OpenPOWER 64-bit ELF
V2 ABI Specification for Power Architecture [2]. As such, it applies to Power
ISA 2.07 and above, requiring the VSX vector facility described in that ABI and
ISA.
<pre><br></pre>
<h2> Calling convention </h2>
The vector functions should use the calling convention described in Section
2.2, Function Calling Sequence, of OpenPOWER 64-bit ELF V2 ABI Specification
for Power Architecture [2] document.

<h2> Vector Length </h2>
Every vector variant of a SIMD-enabled function has a vector length (VLEN).
<pre>

</pre>
If OpenMP clause "simdlen" is used, the VLEN is the value of the argument of
that clause. The VLEN value must be a power of 2.
<pre>

</pre>
In the other cases (GCC simd attribute used or OpenMP simdlen not used) the
notion of a function's "characteristic data type" (CDT) is used to compute the
vector length. CDT is defined in the following order:
<ol>
<li> For non-void function, the CDT is the return type. </li>
<li> If the function has any non-uniform, non-linear parameters, then the CDT
is the type of the first such parameter. </li>
<li> If the CDT determined by a) or b) above is a homogeneous aggregate (see
"Parameter Passing in Registers" in [2]), the CDT is the entire homogeneous
aggregate. For example, a parameter "double x[2]" has a CDT of type double[2]
and size 16 bytes. The same applies for a complex double type.
</li>
<li> If the CDT determined by a) or b) above is a nonhomogeneous struct, union,
or class type (see "Parameter Passing in Registers" in [2]) which is
pass-by-value, the characteristic data type is int. </li>
<li> If none of the above three cases is applicable, the CDT is int. </li>
</ol>
The VLEN is then determined based on the CDT and the size of the vector
register for the ISA. VLEN is computed using the formula below:
<pre><br></pre>
VLEN = sizeof(vector_register) / sizeof(CDT).
<pre><br></pre>
VSX has sizeof(vector_register) = 16.

<h2> Mapping from element data type to vector data type </h2>
The vector data types for parameters are selected depending on ISA, vector
length, data type of original parameter, and parameter specification.
<pre><br></pre>
For uniform and linear parameters (detailed descriptions are found in [1]), the
original data type is preserved. <br>
For vector parameters, vector data types are selected by the compiler. The
mapping from element data type to vector data type is described below.

<ul>
<li> The bit size of the vector data type of a parameter is computed as:<br>
size_of_vector_data_type = VLEN * sizeof(original_parameter_data_type) * 8 <br>
For instance, for a VSX vector function with parameter data type "int": <br>
VLEN = 4, size_of_vector_data_type = 4 * 4 * 8 = 128 bits, which means one
argument of type vector signed int. <br>
</li>
<li>
If the size_of_vector_data_type is greater than the width of the vector
register, multiple vector registers are used for passing the vector parameter.
For instance, a VSX vector function with parameter data type of "double": <br>
VLEN = 4, size_of_vector_data_type = 4 * 8 * 8 = 256 bits, the vector data type
is vector double [2], which means 2 arguments of type vector double are to be
passed.
</li>
</ul>

<h2> Ordering of Vector Arguments </h2>
When a parameter in the original data type results in one argument in the
vector function, the ordering rule is a simple one-to-one match with the
original argument order. <br>
For example, when the original argument list is (int a, float b, int c), VLEN
is 4, and all a, b, and c are classified vector parameters, the vector function
argument list becomes (vector int vec_a, vector float vec_b, vector int vec_c).
<br>
There are cases where a single parameter in the original data type results in
multiple arguments in the vector function. Those additional second and
subsequent arguments are inserted in the argument list right after the
corresponding first argument, not appended to the end of the argument list of
the vector function. For example, if the original argument list is (int a,
double b, int c), VLEN is 4, and all a, b, and c are classified as vector
parameters, the vector function argument list becomes (vector int vec_a, vector
double vec_b1, vector double vec_b2, vector int vec_c). For an example
involving homogeneous aggregates, if the original argument list is (int a,
double b[2], int c), VLEN is 4, and all a, b, and c are classified as vector
parameters, the vector function argument list becomes (vector int vec_a, vector
double vec_b0_0, vector double vec_b0_1, vector double vec_b1_0, vector double
vec_b1_1, vector int vec_c).

<h2> Masking of Vector Functions </h2>
Masking of vector functions is not currently supported by the Power ISA.
Compilers should not generate code for masked variants of vector functions
until such time (if ever) as masked vector instructions are supported.

<h2> Vector Function Name Mangling </h2>
The name mangling of generated vector functions based on standardized
annotation is an important part of this ABI. It allows caller and callee
functions to be separately compiled. Using the function prototypes in header
files to communicate vector function annotation information, the compiler can
perform function matching when vectorizing code at call sites.  The vector
function name is mangled as the concatenation of the following items:
<pre><br></pre>
&ltprefix&gt &ltisa&gt &ltmask&gt &ltlen&gt &ltparameters&gt "_"
&ltoriginal_name&gt
<pre><br></pre>
&ltprefix&gt := "_ZGV"
<pre><br></pre>
&ltoriginal_name&gt := name of scalar function, including C++ mangling
<pre><br></pre>
&ltisa&gt := "b" (VSX)
<pre><br></pre>
&ltmask&gt := "N" (No Mask) <br>
<pre><br></pre>
            | "M" (Mask)
<pre><br></pre>
&ltlen&gt := VLEN <br> <br>
<pre><br></pre>
&ltparameters&gt := /* empty */ <br>
                  | &ltparameter&gt &ltopt-align&gt &ltparameters&gt
<pre><br></pre>
&ltparameter&gt := "l" &ltstride&gt // linear(x:linear_step) or <br>
                                    // linear(val(x):linear_step) when x is a <br>
                                    // pointer <br>
        | "R" &ltstride&gt // linear(ref(x):linear_step) <br>
        | "U" &ltstride&gt // linear(uval(x):linear_step) <br>
        | "L" &ltstride&gt // linear(val(x):linear_step) or <br>
                           // linear(x:linear_step) when x is a reference <br>
        | "u" // uniform parameter <br>
        | "v" // vector parameter
<pre><br></pre>
&ltstride&gt := /* empty */                     // linear_step is equal to 1 <br>
        | "s" &ltnon-negative-decimal-number&gt // linear_step is passed <br>
// in another argument, decimal number is the position # of linear_step <br>
// argument, which starts from 0 <br>
        | &ltnumber&gt // linear_step is literally constant stride
<pre><br></pre>
&ltnumber&gt := [n] non-negative decimal integer // n indicates negative
<pre><br></pre>
&ltopt-align&gt := /* empty*/ <br>
        | "a" non-negative decimal integer
<pre><br></pre>

Please refer to section 2.7, Compiler generated variants of vector functions,
below, for examples of vector function name mangling.
<pre><br></pre>
Note that the value "M" for the &ltmask&gt field is reserved until such time
(if ever) as masked vector instructions are supported in the Power ISA.

<h2> Compiler generated variants of vector functions </h2>
The compiler should generate vector variants, masked and/or umasked as
appropriate, depending on the SIMD construct used to enable vectorization.
Compiler implementations must not generate calls to versions that are
unavailable unless some non-standard pragma or clause is used to declare those
other versions available.
<pre><br></pre>

Example 1. <br>
#pragma omp declare simd notinbranch uniform(q) aligned(q:16) linear(k:1) <br>
float foo (float *q, float x, int k) <br>
{ <br>
  q[k] = q[k] + x; <br>
  return q[k]; <br>
}
<pre><br></pre>

Below is the vector function's prototype given "foo" and its associated pragma.
<ul>
<li> vector float _ZGVbN4ua16vl_foo (float *, vector float, int) </li>
</ul>

Where "foo" is the original function name, "_ZGV" is the prefix of vector
function names, "b" indicates the VSX ISA, "N" indicates an
unmasked version, "4" is the vector length for the ISA, "ua16" indicates
uniform(q) and align(q:16), "v" indicates second argument x is a vector
argument, "l" indicates linear(k:1) - k is a linear variable whose stride is
1.
<pre><br></pre>

Example  2. <br>
#pragma omp declare simd notinbranch <br>
double foo (double x) <br>
{ <br>
  return x * x; <br>
}
<pre><br></pre>

Below is the vector function's prototype given "foo" and its associated pragma.
<ul>
<li> vector double _ZGVbN2v_foo (vector double) </li>
</ul>

Where "foo" is the original function name, "_ZGV" is the prefix of vector
function names, "b" indicates the VSX ISA, "N" indicates an unmasked version,
"2" is the vector length for the ISA/CDT combination, "v" indicates single
argument x is a vector argument. <br>

<h2> References </h2>
[1] OpenMP 4.0 Specification <br>
http://www.openmp.org/mp-documents/OpenMP4.0.0.pdf <br>

[2] OpenPOWER 64-bit ELF V2 ABI Specification - Power Architecture <br>
https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture
<br>

[3] Section 6.33 Declaring Attributes of Functions <br>
https://gnu.org/onlinedocs/gcc/Function-Attributes.html <br>

[4] Section 6.33.1 Common Function Attributes <br>
https://gnu.org/onlinedocs/gcc/Common-Function-Attributes.html <br>

[5] Libmvec <br>
https://sourceware.org/glibc/wiki/libmvec <br>

</body>
</html>
