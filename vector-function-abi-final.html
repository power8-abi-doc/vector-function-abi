<!doctype html>
<html lang=en>
<head><title> POWER8 VSX Vector Function ABI Specification </title>
</head>
<body>

<h1>
Vector Function Application Binary Interface Specification for POWER8 VSX ISA
</h1>

<h2> Vector Function ABI Overview </h2>
Vector Function ABI provides the ABI for vector functions generated by GCC
compilers supporting SIMD constructs of OpenMP 4.0 [1] and above. These SIMD
constructs are also available without OpenMP in GCC compilers that implement
the __attribute__ ((__simd__)) for function declarations and definitions.

The ABI described here applies only for C/C++ functions.

Use of a SIMD construct for a function declaration or definition enables the
creation of vector versions of the function from the scalar version of the
function. The vector variants can be used to process multiple instances
concurrently in a single invocation in a vector context (e.g. mostly typically
in vectorizing loops during the optimization phase of compilation.

For a function definition use of #pragma omp declare simd or __attribute__
((__simd__)) enables creation of vector versions by the compiler.

For a function declaration use of #pragma omp declare simd or __attribute__
((__simd__)) enables the compiler to know the exact list of available vector
function implementations provided by a library. The library's vector functions
will use the OpenMP pragma or GCC attribute SIMD constructs in their
prototypes.

The Vector Function ABI defines a set of rules that caller and callee functions
must obey. The rules consist of:
<ul>
<li> Calling convention (how arguments are passed to the vector function and
how values are returned from the vector function) </li>
<li> Vector length (the number of concurrent scalar invocations to be processed
per invocation of the vector function)</li>
<li> Mapping from element data types to vector data types </li>
<li> Ordering of vector arguments </li>
<li> Vector function masking </li>
<li> Vector function name mangling </li>
<li> Compiler generated vector function variants </li>
</ul>

<h2> Calling convention </h2>
The vector functions should use the calling convention described in Section
2.2, Function Calling Sequence, of OpenPOWER 64-bit ELF V2 ABI Specification
for Power Architecture [2] document.

<h2> Vector Length </h2>
Every vector variant of a SIMD-enabled function has a vector length (VLEN).
<br>
If OpenMP clause "simdlen" is used, the VLEN is the value of the argument of
that clause. The VLEN value must be a power of 2. <br>

In the other cases (GCC simd attribute used or OpenMP simdlen not used) the
notion of a function's "characteristic data type" (CDT) is used to compute the
vector length. CDT is defined in the following order:
<ol>
<li> For non-void function, the CDT is the return type. </li>
<li> If the function has any non-uniform, non-linear parameters, then the CDT
is the type of the first such parameter. </li>
<li> If the CDT determined by a) or b) above is struct, union, or class type
which is pass-by-value (except for the type that maps to the built-in complex
data type), the characteristic data type is int. </li>
<li> If none of the above three cases is applicable, the CDT is int. </li>
</ol>
The VLEN is then determined based on the CDT and the size of the vector
register for POWER8 VSX ISA. VLEN is computed using the formula below: <br>
VLEN = sizeof(vector_register) / sizeof(CDT). <br>
POWER8 VSX ISA has sizeof(vector_register) = 16.

<h2> Mapping from element data type to vector data type </h2>
The vector data types for parameters are selected depending on ISA, vector
length, data type of original parameter, and parameter specification. <br>
For uniform and linear parameters (detailed descriptions are found in [1]), the
original data type is preserved. <br>
For vector parameters, vector data types are selected by the compiler. The
mapping from element data type to vector data type is described below.

<ul>
<li> The bit size of the vector data type of a parameter is computed as:<br>
size_of_vector_data_type = VLEN * sizeof(original_parameter_data_type) * 8 <br>
For instance, for a POWER8 VSX ISA vector function with parameter data type
"int": <br>
VLEN = 4, size_of_vector_data_type = 4 * 4 * 8 = 128 bits, which means one
argument of type vector signed int. <br>
</li>
<li>
If the size_of_vector_data_type is greater than the width of the vector
register, multiple vector registers are used for passing the vector parameter.
For instance, a POWER8 VSX ISA vector function with parameter data type of
"double": <br>
VLEN = 4, size_of_vector_data_type = 4 * 8 * 8 = 256 bits, the vector data type
is vector double [2], which means 2 arguments of type vector double are to be
passed.
</li>
</ul>

<h2> Ordering of Vector Arguments </h2>
When a parameter in the original data type results in one argument in the
vector function, the ordering rule is a simple one-to-one match with the
original argument order. <br>
For example, when the original argument list is (int a, float b, int c), VLEN
is 4, the ISA is POWER8 VSX, and all a, b, and c are classified vector
parameters, the vector function argument list becomes (vector int vec_a, vector
float vec_b, vector int vec_c). <br>
There are cases where a single parameter in the original data type results in
multiple arguments in the vector function. Those additional second and
subsequent arguments are inserted in the argument list right after the
corresponding first argument, not appended to the end of the argument list of
the vector function. For example, if the original argument list is (int a,
double b, int c), VLEN is 4, the ISA is POWER8 VSX, and all a, b, and c are
classified as vector parameters, the vector function argument list becomes
(vector int vec_a, vector double vec_b1, vector double vec_b2, vector int
vec_c).

<h2> Masking of Vector Functions </h2>
A masked vector function variant used for invocation in conditional statements
(please refer to [1] for details) additionally takes an implicit mask argument,
which disables processing of some of the vector lanes. <br>
For masked vector functions, the additional "mask" parameters are required. <br>
Each element of "mask" parameters has the data type of the CDT (see Section 2.2
above). The number of mask parameters is the same as the number of parameters
required to pass the vector of CDT for the given length. The value of a mask
parameter must be either of bit patterns of all ones or all zeros for each
element. <br>
For each element of the vector, if the corresponding mask value is zero, the
return value associated to that element is zero. <br>
Mask parameters are passed after all other parameters in the same order of the
parameters to which they apply.

<h2> Vector Function Name Mangling </h2>
The name mangling of generated vector functions based on standardized
annotation is an important part of this ABI. It allows caller and callee
functions to be separately compiled. Using the function prototypes in header
files to communicate vector function annotation information, the compiler can
perform function matching when vectorizing code at call sites.  The vector
function name is mangled as the concatenation of the following items:
<br>
&ltprefix&gt &ltisa&gt &ltmask&gt &ltlen&gt &ltparameters&gt "_"
&ltoriginal_name&gt <br> <br>
&ltprefix&gt := "_ZGV" <br> <br>
&ltoriginal_name&gt := name of scalar function, including C++ mangling <br> <br>
&ltisa&gt := "b" (POWER8 VSX) <br> <br>
&ltmask&gt := "N" (No Mask) <br>
            | "M" (Mask) <br> <br>
&ltlen&gt := VLEN <br> <br>
&ltparameters&gt := /* empty */ <br>
                  | &ltparameter&gt &ltopt-align&gt &ltparameters&gt <br> <br>
&ltparameter&gt := "s" // linear parameter, variable stride, decimal number is <br>
                       // the position # of stride argument, starting from 0 <br>
                 | "l" &ltnumber&gt // linear parameter, constant stride <br>
                 | "u" // uniform parameter <br>
                 | "v" // vector parameter <br> <br>
&ltnumber&gt := [n] non-negative decimal integer // n indicates negative <br>
&ltopt-align&gt := /* empty*/ <br>
                 | "a" non-negative decimal integer <br> <br>

Please refer to section 2.7, Compiler generated variants of vector function,
below for examples of vector function name mangling.

<h2> Compiler generated variants of vector function </h2>
The compiler should generate vector variants, masked and/or umasked as
appropriate, depending on the SIMD construct used to enable vectorization.
Compiler implementations must not generate calls to versions that are
unavailable unless some non-standard pragma or clause is used to declare those
other versions available. <br>

Example 1. <br>
#pragma omp declare simd uniform(q) aligned(q:16) linear(k:1) <br>
float foo (float *q, float x, int k) <br>
{ <br>
  q[k] = q[k] + x; <br>
  return q[k]; <br>
} <br>
<br>
Below is the list of generated function names or list of symbols provided by a
library with the same pragma in "foo" prototype.
<ol>
<li> _ZGVbN4ua16vl_foo (POWER8 VSX ISA, unmasked version) </li>
<li> _ZGVbM4ua16vl_foo (POWER8 VSX ISA, masked version) </li>
</ol>

Where "foo" is the original function name, "_ZGV" is the prefix of vector
function names, "b" indicated the POWER8 VSX ISA and computed CDT, "N"
indicates an unmasked version, "M" indicates a masked version, "4" is the
vector length for the ISA, "ua16" indicates uniform(q) and align(a:32), "v"
indicates second argument x is a vector argument, "l" indicates linear(k:1) - k
is a linear variable whose stride is 1a. <br>

Example  2. <br>
#pragma omp declare simd notinbranch <br>
double foo (double x) <br>
{ <br>
  return x * x; <br>
} <br>
Below is the list of generated function names or list of symbols provided by a
library with the same pragma in "foo" prototype.
<ol>
<li> _ZGVbN2v_foo (POWER8 VSX ISA, unmasked version) </li>
</ol>
Where "foo" is the original function name, "_ZGV" is the prefix of vector
function names, "b" indicated the POWER8 VSX ISA, "N" indicates an unmasked
version, "2" is the vector length for the ISA/CDT combination, "v" indicates
single argument x is a vector argument. <br>

<h2> References </h2>
[1] OpenMP 4.0 Specification <br>
http://www.openmp.org/mp-documents/OpenMP4.0.0.pdf <br>

[2] OpenPOWER 64-bit ELF V2 ABI Specification - Power Architecture <br>
https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture
<br>

[3] Section 6.33 Declaring Attributes of Functions <br>
https://gnu.org/onlinedocs/gcc/Function-Attributes.html <br>

[4] Section 6.33.1 Common Function Attributes <br>
https://gnu.org/onlinedocs/gcc/Common-Function-Attributes.html <br>

[5] Libmvec <br>
https://sourceware.org/glibc/wiki/libmvec <br>

</body>
</html>
